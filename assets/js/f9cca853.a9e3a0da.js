"use strict";(self.webpackChunktestpro=self.webpackChunktestpro||[]).push([[9045],{3337:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"java-multithreading/mutex-semaphore-monitor","title":"Mutex, Semaphore, Monitor","description":"Mutex vs Semaphore","source":"@site/docs/java-multithreading/mutex-semaphore-monitor.mdx","sourceDirName":"java-multithreading","slug":"/java-multithreading/mutex-semaphore-monitor","permalink":"/docs/java-multithreading/mutex-semaphore-monitor","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java-multithreading/mutex-semaphore-monitor.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Preemptive multitasking","permalink":"/docs/java-multithreading/multitasking-model"},"next":{"title":"Program","permalink":"/docs/java-multithreading/process-and-thread"}}');var n=i(6070),a=i(8637);const r={},s="Mutex, Semaphore, Monitor",h={},c=[{value:"Mutex vs Semaphore",id:"mutex-vs-semaphore",level:2},{value:"Predicate",id:"predicate",level:2},{value:"Monitor",id:"monitor",level:2},{value:"why use <code>while</code> instead of <code>if</code> in the condition variable",id:"why-use-while-instead-of-if-in-the-condition-variable",level:3},{value:"definition of monitor",id:"definition-of-monitor",level:3},{value:"Every object in Java has a monitor",id:"every-object-in-java-has-a-monitor",level:3},{value:"Categories of monitor",id:"categories-of-monitor",level:2},{value:"Optimistic vs Pessimistic locking",id:"optimistic-vs-pessimistic-locking",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"mutex-semaphore-monitor",children:"Mutex, Semaphore, Monitor"})}),"\n",(0,n.jsx)(t.h2,{id:"mutex-vs-semaphore",children:"Mutex vs Semaphore"}),"\n",(0,n.jsx)(t.p,{children:"Mutex only allows one thread that has locked the mutex to release it. Here comes the concept of ownership.So that mutex involves ownership, but semaphore does't have."}),"\n",(0,n.jsx)(t.p,{children:"Semaphore allows multiple threads to access the shared resource. But when relase the semaphore, it doesn't need to be the thread that locked the semaphore to release. So, semaphore doesn't involve ownership. Here, Semaphore allows the signal transmission between threads, but mutex doesn't."}),"\n",(0,n.jsx)(t.h2,{id:"predicate",children:"Predicate"}),"\n",(0,n.jsx)(t.p,{children:"In the context of multi-threading or concurrency or parallelism, a predicate means a condition that allows the program to proceed in a certain way. A predicate is a boolean expression that evaluates to true or false."}),"\n",(0,n.jsx)(t.h2,{id:"monitor",children:"Monitor"}),"\n",(0,n.jsx)(t.p,{children:'In Java, Monitor exists in the form of synchronized blocks or methods. But at the very beginning, you can imagine that monitor is a combination of mutex and condition variable. Let\'s see the following example. The first example is an exampl of "spin waiting" and the second example is a solution to "spin waiting".'}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-Java",children:"void busyWaitFunction() {\n  // acquire mutex\n  while (predicate is false){\n    // release mutex\n   // acquire mutex\n}\n  // do something useful\n // release mutex\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:'Within the first example, a thread will keep spinning in the while loop until the predicate becomes true. This is called "spin waiting". This is a waste of CPU cycles. In this example, other threads can only change the predicate when the current thread releases the mutex. But if the current thread is acquire the mutex so soon, other threads can hardly change the predicate.'}),"\n",(0,n.jsx)(t.p,{children:"The solution to above problem is to use condition variable. The condition variable is a mechanism that allows a thread to wait for a certain condition to become true. When the condition becomes true, the thread is notified and can proceed. The following is an example of using condition variable."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-Java",children:"  voidefficientWaitingFunction() \n{\n  mutex.acquire() \n  while (predicate == false) {\n    condVar.wait()\n  }\n // Do something useful\n  mutex.release()\n}\n\nvoid changePredicate(){\n  mutex.acquire()\n  set predicate = true\n  condVar.signal()\n  mutex.release()\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In the second example, the thread will wait for the predicate to become true. But here a variable called ",(0,n.jsx)(t.code,{children:"condVar"}),' is used to wait for the predicate to become true. When the predicate becomes true, the thread is notified and can proceed. This is called "efficient waiting". The ',(0,n.jsx)(t.code,{children:"condVar.wait()"})," will release the mutex and wait for the predicate to become true. You can imagine that there is a waiting room, once invoke ",(0,n.jsx)(t.code,{children:"condVar.wait()"}),", the thread will go to the waiting room and wait for ",(0,n.jsx)(t.code,{children:"conVar.signal()"})," to be notified, once got signaled, the thread come back to work from rest."]}),"\n",(0,n.jsxs)(t.h3,{id:"why-use-while-instead-of-if-in-the-condition-variable",children:["why use ",(0,n.jsx)(t.code,{children:"while"})," instead of ",(0,n.jsx)(t.code,{children:"if"})," in the condition variable"]}),"\n",(0,n.jsxs)(t.p,{children:["Noticed that we didn't use ",(0,n.jsx)(t.code,{children:"if"})," in the condition variable, but ",(0,n.jsx)(t.code,{children:"while"}),". By using ",(0,n.jsx)(t.code,{children:"while"}),', we can avoid something called "spurious wakeup". The "spurious wakeup" means that a thread can wake up without being notified. How can this happen? The reason is that the thread can wake up by some signal, however, when the signaled thread check the predicate, the predicate is still false since some other thread change the predicate during "woking up". So, the thread should go back to the waiting room and wait for the predicate to become true again.']}),"\n",(0,n.jsxs)(t.p,{children:["If we use ",(0,n.jsx)(t.code,{children:"if"}),", the thread will go to work without checking the predicate again, which is wrong. In the if case, we need to guarantee that the predicate won't be changed during the \"waking up\" process. But in the real world, we can't guarantee that. So, we use ",(0,n.jsx)(t.code,{children:"while"}),' to avoid "spurious wakeup".']}),"\n",(0,n.jsxs)(t.p,{children:["Thus, it becomes a convention to use ",(0,n.jsx)(t.code,{children:"while"})," instead of ",(0,n.jsx)(t.code,{children:"if"})," in the condition variable."]}),"\n",(0,n.jsx)(t.h3,{id:"definition-of-monitor",children:"definition of monitor"}),"\n",(0,n.jsx)(t.p,{children:"After the above discussion, we can now realize that a monitor is made up of a mutex and one or more condition variables. A single monitor can have multiple condition variables but not vice versa."}),"\n",(0,n.jsx)(t.p,{children:"Theoretically, another way to think about a monitor is to consider it as an entity having two queues or sets where threads can be placed. One is the entry set and the other is the wait set. When a thread A enters a monitor it is placed into the entry set. If no other thread owns the monitor, which is equivalent of saying no thread is actively executing within the monitor section, then thread A will acquire the monitor and is said to own it too. Thread A will continue to execute within the monitor section till it exits the monitor or calls wait() on an associated condition variable and be placed into the wait set. While thread A owns the monitor no other thread will be able to execute any of the critical sections protected by the monitor. New threads requesting ownership of the monitor get placed into the entry set."}),"\n",(0,n.jsx)(t.h3,{id:"every-object-in-java-has-a-monitor",children:"Every object in Java has a monitor"}),"\n",(0,n.jsx)(t.p,{children:"Practically, in Java each object is a monitor and implicitly has a lock and is a condition variable too. You can think of a monitor as a mutex with a wait set. Monitors allow threads to exercise mutual exclusion as well as cooperation by allowing them to wait and signal on conditions."}),"\n",(0,n.jsx)(t.h2,{id:"categories-of-monitor",children:"Categories of monitor"}),"\n",(0,n.jsx)(t.p,{children:"There are two categories of monitor, mesa style and hoare style. The difference between them is how the condition variable works. In mesa style, the condition variable can be signaled without the mutex being held. In hoare style, the condition variable can only be signaled when the mutex is held. Java uses mesa style. Java uses mesa style. Mesa style is more practical and efficient than hoare style."}),"\n",(0,n.jsx)(t.h2,{id:"optimistic-vs-pessimistic-locking",children:"Optimistic vs Pessimistic locking"}),"\n",(0,n.jsx)(t.p,{children:"Optimistic locking is a strategy where a thread doesn't acquire a lock before accessing a shared resource. Instead, it accesses the shared resource and checks if the resource has been modified by another thread. If the resource has been modified, the thread retries the operation. Optimistic locking is used when the probability of contention is low. Pessimistic locking is a strategy where a thread acquires a lock before accessing a shared resource. Pessimistic locking is used when the probability of contention is high."})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8637:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>s});var o=i(758);const n={},a=o.createContext(n);function r(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);