"use strict";(self.webpackChunktestpro=self.webpackChunktestpro||[]).push([[630],{2392:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var a=n(758);const o={},r=a.createContext(o);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:t},e.children)}},7322:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"java-multithreading/types-of-computation","title":"types-of-computation","description":"Four factor need to think when coding","source":"@site/docs/java-multithreading/types-of-computation.mdx","sourceDirName":"java-multithreading","slug":"/java-multithreading/types-of-computation","permalink":"/docs/java-multithreading/types-of-computation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java-multithreading/types-of-computation.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Program","permalink":"/docs/java-multithreading/process-and-thread"},"next":{"title":"Tutorial - Basics","permalink":"/docs/category/tutorial---basics"}}');var o=n(6070),r=n(2392);const s={},i="I/O Bound programs",c={},h=[{value:"Deadlock",id:"deadlock",level:2},{value:"Livelock",id:"livelock",level:2},{value:"Starvation",id:"starvation",level:2},{value:"Reenterant Locks",id:"reenterant-locks",level:2}];function d(e){const t={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Four factor need to think when coding\nCPU time\nMemory\nnetwork"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"throughput"}),"\n",(0,o.jsx)(t.li,{children:"latency\ndisk storage"}),"\n"]}),"\n",(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"io-bound-programs",children:"I/O Bound programs"})}),"\n",(0,o.jsx)(t.h1,{id:"cpu-bound-programs",children:"CPU Bound programs"}),"\n",(0,o.jsx)(t.h1,{id:"throughput",children:"Throughput"}),"\n",(0,o.jsx)(t.p,{children:"Throughput is defined as the rate of doing work or how much work gets done per unit of time. If you are an Instagram user, you could define throughput as the number of images your phone or browser downloads per unit of time."}),"\n",(0,o.jsx)(t.h1,{id:"latency",children:"Latency"}),"\n",(0,o.jsx)(t.p,{children:"Latency is defined as the time required to complete a task or produce a result. Latency is also referred to as response time. The time it takes for a web browser to download Instagram images from the internet is the latency for downloading the images."}),"\n",(0,o.jsx)(t.h1,{id:"throughput-vs-latency",children:"Throughput vs Latency"}),"\n",(0,o.jsx)(t.p,{children:"The two terms are more frequently used when describing networking links and have more precise meanings in that domain. In the context of concurrency, throughput can be thought of as time taken to execute a program or computation. For instance, imagine a program that is given hundreds of files containing integers and asked to sum up all the numbers. Since addition is commutative each file can be worked on in parallel. In a single-threaded environment, each file will be sequentially processed but in a concurrent system, several threads can work in parallel on distinct files. Of course, there will be some overhead to manage the state including already processed files. However, such a program will complete the task much faster than a single thread. The performance difference will become more and more apparent as the number of input files increases. The throughput in this example can be defined as the number of files processed by the program in a minute. And latency can be defined as the total time taken to completely process all the files. As you observe in a multithreaded implementation throughput will go up and latency will go down. More work gets done in less amount of time. In general, the two have an inverse relationship."}),"\n",(0,o.jsx)(t.h1,{id:"critical-section",children:"Critical Section"}),"\n",(0,o.jsx)(t.p,{children:"Critical section is any piece of code that has the possibility of being executed concurrently by more than one thread of the application and exposes any shared data or resources used by the application for access."}),"\n",(0,o.jsx)(t.h1,{id:"race-condition",children:"Race Condition"}),"\n",(0,o.jsx)(t.p,{children:"Race conditions happen when threads run through critical sections without thread synchronization. The threads \u201crace\u201d through the critical section to write or read shared resources and depending on the order in which threads finish the \u201crace\u201d, the program output changes. In a race condition, threads access shared resources or program variables that might be worked on by other threads at the same time causing the application data to be inconsistent."}),"\n",(0,o.jsx)(t.p,{children:"As an example consider a thread that tests for a state/condition, called a predicate, and then based on the condition takes subsequent action. This sequence is called test-then-act. The pitfall here is that the state can be mutated by the second thread just after the test by the first thread and before the first thread takes action based on the test. A different thread changes the predicate in between the test and act. In this case, action by the first thread is not justified since the predicate doesn\u2019t hold when the action is executed."}),"\n",(0,o.jsx)(t.h1,{id:"to-prevent-race-conditions-we-use-locks",children:"To prevent race conditions, we use locks"}),"\n",(0,o.jsx)(t.h2,{id:"deadlock",children:"Deadlock"}),"\n",(0,o.jsx)(t.p,{children:"Deadlocks occur when two or more threads aren\u2019t able to make any progress because the resource required by the first thread is held by the second and the resource required by the second thread is held by the first."}),"\n",(0,o.jsx)(t.h2,{id:"livelock",children:"Livelock"}),"\n",(0,o.jsx)(t.p,{children:"A live-lock occurs when two threads continuously react in response to the actions by the other thread without making any real progress. The best analogy is to think of two persons trying to cross each other in a hallway. John moves to the left to let Arun pass, and Arun moves to his right to let John pass. Both block each other now. John sees he\u2019s blocking Arun again and moves to his right and Arun moves to his left seeing he\u2019s blocking John. They never cross each other and keep blocking each other. This scenario is an example of a livelock. A process seems to be running and not deadlocked but in reality, isn\u2019t making any progress."}),"\n",(0,o.jsx)(t.h2,{id:"starvation",children:"Starvation"}),"\n",(0,o.jsx)(t.p,{children:"Starvation occurs when a thread is unable to gain access to shared resources because other threads are continuously using the resources. The thread is said to be starved of resources. Starvation can be avoided by using a fair scheduling algorithm that ensures that all threads get a fair share of resources."}),"\n",(0,o.jsx)(t.h2,{id:"reenterant-locks",children:"Reenterant Locks"}),"\n",(0,o.jsx)(t.p,{children:"Re-entrant locks allow for re-locking or re-entering of a synchronization lock. This can be best explained with an example. Consider the NonReentrant class below."}),"\n",(0,o.jsx)(t.p,{children:"If a synchronization primitive doesn\u2019t allow reacquisition of itself by a thread that has already acquired it, then such a thread would block as soon as it attempts to reacquire the primitive a second time."})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);